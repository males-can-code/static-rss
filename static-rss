#!/usr/bin/python3

import os,sys
import feedparser
import hashlib
import sqlite3
import shutil
import subprocess
from lib.log import Log
from time import strftime
from string import Template
from config import Config

class GenerateHTML(object):
    def copy_file(self, src, dest):
    # Copy a file
        try:
            shutil.copy(src, dest)
            return True
        except IOError as e:
            self.log.error('Failed to copy file: %s. Quitting...'%src)
            sys.exit()


    def remove_dir(self, path):
    # TODO This needs work, the dir is not removed
    # Remove a tree
        if os.path.exists(path):
            try:
                shutil.rmtree(path)
            except:
                pass


    def check_dir(self, path):
    # Create dir if it doesn't exist, otherwise do nothing
        if not os.path.exists(path):
            try:
                os.makedirs(path)
                return True
            except IOError as e:
                self.log.error('Failed to create dir: %s. Quitting...'%path)
                sys.exit()
        else:
            return True


    def check_file(self, filename):
    # Check if file exists
        try:
            with open(filename) as f: pass
            return True
        except IOError as e:
            self.log.info('Failed to open file: %s'%filename)
            return False
        

    def get_file(self, filename):
    # Get file contents
        contents = []
        if self.check_file(filename):
            try:
                f = open(filename, 'r')
            except IOError as e:
                self.log.info('Failed to open file: %s'%filename)
                return False

            for line in f:
                contents.append(self.sanitize(line))
            f.close()
            return contents
        else:
            return False
            

    def write_to_file(self, path, data):
    # (over)write data to file
        try:
            with open(path, 'w') as f:
                f.write(data)
        except IOError:
            self.log.error('Failed to write to file: %s. Quitting...'%path)
            sys.exit()


    def parse_template(self, template_path, data):
    # Parse a template file, input is a dict and return is a string
        filled_template = ''
        template = self.get_file(template_path)

        if template:
            for line in template:
                for key in data.keys():
                    if '$' + key in line:
                        line = Template(line).safe_substitute({key:data[key]})
                filled_template = filled_template + line + '\n'
        return filled_template


    def generate_feed_urls(self, feeds):
    # Generate the left sidebar links
        filled_template = ''
        feed_url = {}

        for group in self.get_groups():
            feeds = self.get_rows_by_value('feeds', 'groups',  group)
            filled_group_template = self.parse_template(self.config.path_template_feed_list_group, {'group_title' : group})
            filled_template = filled_template + filled_group_template + '\n'
        
            for feed in feeds:
                # Count unread entries per feed
                entries = self.get_rows_by_value('entries', 'feed_hash', feed['hash'], order_by='date_published')
                unread_counter = 0
                for entry in entries:
                    if entry['read'] == 'unread':
                        unread_counter = unread_counter + 1

                feed_url['title'] = feed['title'] 
                feed_url['feed_url']= self.config.domain + '/feeds/' + feed['hash'] + '/page_1.html'

                # Parse template
                if unread_counter > 0:
                    feed_url['counter'] = '[' + str(unread_counter) + ']'
                    feed_url['read'] = 'unread'
                else:
                    feed_url['counter'] = ''
                    feed_url['read'] = 'read'

                filled_url_template = self.parse_template(self.config.path_template_feed_list_link, feed_url)
                filled_template = filled_template + filled_url_template + '\n'
        return filled_template


    def generate_entries(self, feed, page):
    # Generate a page with entries (posts)
        filled_entries_template = ''
        entries = self.get_rows_by_value('entries', 'feed_hash', feed['hash'], order_by='date_published') 
        for entry in entries:
            for hash in page:
                if hash == entry['hash']:
                    filled_entry_template = self.parse_template(self.config.path_template_entry, entry)
                    filled_entries_template = filled_entries_template + filled_entry_template + '\n'
        return filled_entries_template


    def generate_entry_list(self, feed):
    # Generate the right sidebar links
        titles = ''
        title = {}
        pages = self.calculate_pages(feed)
        entries = self.get_rows_by_value('entries', 'feed_hash', feed['hash'], order_by='date_published', limit=self.config.max_entries_in_sidebar) 

        for entry in entries:
            page_count = 1
            for page in pages:
                if entry['hash'] in page:
                    entry['entry_url'] = self.config.domain + '/feeds/' + feed['hash'] + '/page_' + str(page_count) + '.html' 
                page_count = page_count + 1

            filled_template = self.parse_template(self.config.path_template_entry_list_link, entry)
            titles = titles + filled_template + '\n'
        return titles


    def generate_page_links(self, feed_hash, n_pages):
    # Generate the links to the different pages with entries for a feed
        page_links = ''
        for x in range(1,n_pages + 1):
            link = {}
            link['page_url'] = self.config.domain + '/feeds/' + feed_hash + '/page_' + str(x) + '.html'
            link['page'] = x
            filled_template = self.parse_template(self.config.path_template_page_link, link)
            page_links = page_links + filled_template + '\n'
        return page_links


    def generate_prev_link(self, pages, feed, cur_page):
    # Generate the link to the previous page (left from the page links)
        if cur_page == len(pages):
            return self.config.domain + '/feeds/' + feed['hash'] + '/page_' + str(cur_page - 1) + '.html'
        elif cur_page > 0:
            return self.config.domain + '/feeds/' + feed['hash'] + '/page_' + str(cur_page) + '.html'


    def generate_next_link(self, pages, feed, cur_page):
    # Generate the link to the next page (right from the page links)
        if cur_page == len(pages):
            return self.config.domain + '/feeds/' + feed['hash'] + '/page_' + str(cur_page) + '.html'
        elif cur_page > 0:
            return self.config.domain + '/feeds/' + feed['hash'] + '/page_' + str(cur_page + 1) + '.html'


    def calculate_pages(self, feed):
    # Calculate on how many pages the entries will be spread out
        sum_chars = 0
        entry_hash_list = []
        pages = []
        c = 1

        entries = self.get_rows_by_value('entries', 'feed_hash', feed['hash'], order_by='date_published') 
        for entry in entries:
            sum_chars = sum_chars + len(entry['content'])
            entry_hash_list.append(entry['hash'])
            if sum_chars >= self.config.max_chars_per_page or c == len(entries):
                pages.append(entry_hash_list)
                entry_hash_list = []
                sum_chars = 0
            c = c + 1
                
        return pages


    def gen_init(self, feeds):
    # Create/remove/copy dirs and files
        self.remove_dir(self.config.path_export_html)
        self.check_dir(self.config.path_export_html)
        self.check_dir(self.config.path_export_html + '/feeds')
        self.check_dir(self.config.path_export_html + '/css')
        self.check_dir(self.config.path_export_html + '/php')
        self.check_dir(self.config.path_export_html + '/js')

        for feed in feeds:
            self.check_dir(self.config.path_export_html + '/feeds/' + feed['hash'])

        self.copy_file(self.config.path_css, self.config.path_export_html + '/css')
        self.copy_file(self.config.path_script_update, self.config.path_export_html + '/php')
        self.copy_file(self.config.path_script_mark_read, self.config.path_export_html + '/php')
        self.copy_file(self.config.config_dir + '/js/jquery.slimscroll.min.js', self.config.path_export_html + '/js')
        self.copy_file(self.config.path_favicon, self.config.path_export_html)


    def generate_HTML(self):
    # The main method that calls the other method in class and eventually generates the HTML
        self.log.info('Generating HTML')
        feeds = self.get_table('feeds')     # Get a list of dicts containing information about a feed
        self.gen_init(feeds)                # Remove/create and copy dirs and files

        feed_template = {}                  # feed_template dict contains main content for the 'feed.html' template 
        feed_template['update_interval'] = self.config.update_interval
        feed_template['feed_urls']       = self.generate_feed_urls(feeds)
        feed_template['domain']          = self.config.domain
        feed_template['favicon']         = self.config.domain + '/favicon.ico'
        feed_template['css']             = self.config.domain + '/css/stylesheet.css'

        # Create html pages for every page of every feed
        for feed in feeds:
            # Calculate in how many pages the entries fit
            pages = self.calculate_pages(feed)

            feed_template['page_links'] = self.generate_page_links(feed['hash'], len(pages))
            feed_template['entry_list'] = self.generate_entry_list(feed)
            feed_template['title']      = feed['title']
            feed_template['hash']       = feed['hash']

            page_count = 1
            for page in pages:
                feed_template['page_next'] = self.generate_next_link(pages, feed, page_count)
                feed_template['page_prev'] = self.generate_prev_link(pages, feed, page_count)
                feed_template['content']   = self.generate_entries(feed, page)
                feed_template['go_back']    = '%s/feeds/%s/page_%s.html' %(self.config.domain, feed['hash'], str(page_count))

                # Parse the template and write to file
                filled_feed_template = self.parse_template(self.config.path_template_feed, feed_template)
                self.write_to_file('%s/feeds/%s/page_%s.html' %(self.config.path_export_html, feed['hash'], str(page_count)), filled_feed_template)

                # First feed, first page will be index.html
                if feed == feeds[0] and page_count == 1:
                    self.write_to_file(self.config.path_export_html + '/index.html', filled_feed_template)

                page_count = page_count + 1



class Database(object):
    def create_tables(self): 
    # Create database and tables
        db = sqlite3.connect(self.config.path_db)
        db.execute("create table if not exists feeds (hash          text    unique  ,"
                                                     "title         text            ,"
                                                     "date_entered  text            ,"
                                                     "feed_url      text            ,"
                                                     "icon_url      text            ,"
                                                     "last_updated  text            ,"
                                                     "groups        text            )")

        db.execute("create table if not exists entries (hash            text    unique  ,"
                                                        "content        text            ,"
                                                        "entry_url      text            ,"
                                                        "title          text            ,"
                                                        "read           text            ,"
                                                        "date_entered   text            ,"
                                                        "date_published text            ,"
                                                        "feed_hash      text            )")
        db.commit()
        db.close()


    def get_table(self, table, order_by='ROWID'):
    # Spits out the complete table into a list of dictionaries
        db = sqlite3.connect(self.config.path_db)
        rows = []
        cols = []
        table_export = []

        for row in db.execute('select * from %s order by %s'%(table,order_by)):
            rows.append(row)

        for row in db.execute('PRAGMA table_info(%s)'%table):
            cols.append(row[1])

        for row in rows:
            row_export = {}
            for x in range(0,len(cols)):
                row_export[cols[x]] = row[x]
            table_export.append(row_export)

        db.close()
        return table_export


    def get_rows_by_value(self, table, col, value, order_by='date_entered', limit='all'):
    # Get a list of all rows containing a value
        db = sqlite3.connect(self.config.path_db)
        rows = []
        cols = []
        rows_export = []
        if limit == 'all':
            for row in db.execute('select * from %s where "%s" is "%s" order by "%s" desc'%(table, col, value, order_by)):
                rows.append(row)
        else:
            for row in db.execute('select * from %s where "%s" is "%s" order by "%s" desc limit %s'%(table, col, value, order_by, limit)):
                rows.append(row)

        for row in db.execute('PRAGMA table_info(%s)'%table):
            cols.append(row[1])

        for row in rows:
            row_export = {}
            for x in range(0,len(cols)):
                row_export[cols[x]] = row[x]
            rows_export.append(row_export)

        db.close()
        return rows_export


    def insert_row(self, table, row):
    # Insert a row
        db = sqlite3.connect(self.config.path_db)
        values = []
        for key in row:
            values.append(row[key])
        keys = ','.join(row.keys())
        query = 'INSERT INTO %s(%s) VALUES(%s)'%(table, keys, ','.join(['?'] * len(row)))
        try:
            db.execute(query,values)
            db.commit()
            db.close()
        except:
            self.log.error('Failed to insert row')
            db.close()


    def update_row(self, table, field, string, hash):
    # Update one or more rows
        db = sqlite3.connect(self.config.path_db)
        db.execute('update %s set "%s" = "%s" where "%s"'%(str(table), str(field), str(string), str(hash)))
        db.commit()
        db.close()


    def check_in_table(self, table, col, value):
    # Return True/False if a value exists in table
        db = sqlite3.connect(self.config.path_db)
        for data in db.execute('select * from "%s" where "%s" = "%s"'%(str(table),str(col),str(value))):
            if data:
                db.close()
                return True
        db.close()
        return False
        


class RSS(Database, GenerateHTML):
    def __init__(self):
        self.log = Log()
        self.config = Config()


    def get_timestamp(self):
        timestamp = strftime("%Y-%m-%d %H:%M:%S")
        return timestamp


    def get_hash(self, data):
    # Clean up var and create a hash of data
        data = self.sanitize(data)
        data = self.encode(data)
        hashed = hashlib.sha224(data).hexdigest()
        return hashed


    def get_groups(self):
    # Get a list of groups that contain feeds
        group_list = []
        feeds = self.get_table('feeds')
        for feed in feeds:
            if feed['groups'] not in group_list:
                group_list.append(feed['groups'])
        return group_list


    def parse_feed(self, url):
    # Parse feed with feedparser module or return False
        self.log.info('Parsing: %s'%url)
        try:
            parsed_feed = feedparser.parse(url)
            return parsed_feed
        except:
            self.log.error('Failed to parse feed: %s'%url)
            return False


    def parse_feeds(self):
    # Parse all feeds, calls parse_feed()
        feeds = self.get_table('feeds')
        for feed in feeds:
            parsed_feed = self.parse_feed(feed['feed_url'])
            if parsed_feed:
                for entry in parsed_feed.entries:
                    if not self.check_in_table('entries', 'hash', str(self.get_hash(entry['title'] + entry['summary']))):
                        self.add_entry(entry, feed['feed_url'])


    def sanitize(self, var):
    # Strip file from blanks and newlines
        var = var.strip()
        return var


    def encode(self, data):
    # Convert var to utf-8
        try:
            data = data.encode('utf-8')
            return data
        except:
            self.log.warning('Failed to encode data, data is already urf-8?')


    def add_feed(self, feed):
    # Gather information to add feed to database
        self.log.info('Adding feed: %s'%feed[0])
        feed_insert = {}
        parsed_feed = self.parse_feed(feed[0])
        if parsed_feed:
            feed_insert['hash'] = str(self.get_hash(feed[0]))
            feed_insert['date_entered'] = str(self.get_timestamp())
            feed_insert['feed_url'] = str(feed[0])
            feed_insert['icon_url'] = 'None'
            feed_insert['last_updated'] = 'None'
            feed_insert['groups'] = feed[1]

            if 'title' in parsed_feed.feed.keys():
                feed_insert['title'] = str(parsed_feed.feed['title'])
            else:
                feed_insert['title'] = str(feed[0])

            self.insert_row('feeds', feed_insert)


    def add_entry(self, entry, url):
    # Gather information to add entry (post) to database
        self.log.info('Inserting new entry: %s'%entry['title'])
        entry_insert = {}

        # Try to get title otherwise insert link or unknown
        try:
            entry_insert['title']           = str(entry['title'])
        except:
            try:
                entry_insert['title']           = str(entry['link'])
                self.log.warning('Failed to find title, using \'url\'')
            except:
                entry_insert['title']           = 'unknown'
                self.log.warning('Failed to find title, using \'unknown\'')

        entry_insert['hash']            = str(self.get_hash(entry['title'] + entry['summary']))
        entry_insert['content']         = str(entry['summary'])
        entry_insert['read']            = 'unread'
        entry_insert['date_entered']    = str(self.get_timestamp())
        entry_insert['feed_hash']       = str(self.get_hash(url))

        # Try to get url otherwise insert unknown
        try:
            entry_insert['entry_url']       = str(entry['link'])
        except:
            entry_insert['entry_url']       = 'unknown'
            self.log.warning('Failed to find url for entry, using \'unknown\'')

        # Try to get a date if available otherwise insert timestamp
        try:
            p = entry.published_parsed
        except:
            try:
                p = entry.updated_parsed
            except:
                try:
                    p = entry.created_parsed
                except:
                    p = False

        if p:
            # The date as returned from feedparser is in form: 2013-1-12, and must be 2013-01-12
            date = []
            for x in p:
                date.append(str(x).rjust(2,'0'))
            entry_insert['date_published'] = str('%s-%s-%s %s:%s:%s'%(date[0],date[1],date[2],date[3],date[4],date[5]))
        else:
            entry_insert['date_published'] = str(self.get_timestamp())
            self.log.warning('Failed to find a date, using timestamp')

        self.insert_row('entries', entry_insert)


    def mark_read(self, feed):
    # Mark a feed as read
        self.log.info('Marking feed read: %s'%feed['title'])
        self.update_row('entries', 'read', 'read', feed['hash'])


    def mark_all_read(self):
    # Mark all feeds as read, calls mark_read()
        feeds = self.get_table('feeds')
        for feed in feeds:
            self.mark_read(feed)


    def init(self):
    # Create tables, input feeds from config file in table
    # TODO are there feeds? what will happen if not?
        self.create_tables()

        if len(self.config.feeds) >= 1:
            for feed in self.config.feeds:
                if not self.check_in_table('feeds', 'hash', str(self.get_hash(feed[0]))):
                    self.add_feed(feed)
        else:
            self.log.error('No feeds configured, Quitting...')


    def usage(self):
    # Display help
        print('static-rss - An RSS reader that outputs static HTML')
        print('Syntax: static-rss [OPTION]...')
        print()
        print('Options:')
        print('    -p, --parse-feeds              -parse feeds')
        print('    -g, --gen-html                 -generate HTML')
        print('    -m, --mark-all-read            -mark all feeds as read')
        print()
        print('    -h, --help                     -this text')
                                                                 

    def run(self):
        if len(sys.argv) <= 1:
            self.usage()
            sys.exit()

        if '-h' in sys.argv or '--help' in sys.argv:
            self.usage()
            sys.exit()

        if len(sys.argv) >= 2:
            self.init()

            if '--parse-feeds' in sys.argv or '-p' in sys.argv:
                self.parse_feeds()

            if '--mark-all-read' in sys.argv or '-m' in sys.argv:
                self.mark_all_read()

            if '--gen-html' in sys.argv or '-g' in sys.argv:
                self.generate_HTML()
                sys.exit()

            self.usage()

app = RSS()
app.run()
